* Implementing SSL
* **How ssl create a secure connection?**

```bash
+---------+                           +---------+
|         | <-------- Step 1 -------- |         |
| Browser |                           | Server  |
|         | -------- Step 2 ------->  |         |
|         | <-------- Step 3 -------- |         |
|         | -------- Step 4 ------->  |         |
+---------+                           +---------+
```

**Step 1 — Browser → Server: ClientHello**

The browser sends:
- Supported TLS versions
- Supported ciphers
- A random number (client_random)

*This starts the handshake*

**Step 2 — Server → Browser: ServerHello + Certificate**
The server responds with:
- Chosen cipher
- A random number (server_random)
- SSL certificate (contains server public key)
- Sometimes additional handshake data (like DH params)
*Browser now tries to verify the certificate using trusted Certificate Authorities (CAs)*

**Step 3 — Browser Creates the Session Key**
A secure "session key" is generated by the browser
But how it’s shared depends on the key exchange type:
**In older RSA handshake:**
- Client encrypts session key with server’s public key
- Sends it to the server
**In modern TLS (ECDHE – preferred)**
- Browser & server perform a Diffie–Hellman key exchange
- Both sides independently derive the same shared session key
- ***No key is ever transmitted** → more secure & supports perfect forward secrecy*

**Step 4 — Server Confirms Key**
The server:
- Uses its private key to decrypt (RSA method) or
- Completes DH exchange
- Derives the same session key
- Sends a Finished message encrypted using that session key
*This proves the server successfully derived the correct symmetric key*

**Step 5 — Secure Symmetric Encryption Begins**
*Now both sides have:*
* One shared symmetric session key
* Used for fast encryption of all further data

*Why symmetric?*
- Because symmetric encryption is much faster than public-key encryption


#### Final Corrected Summary (Clean Version)

1. ClientHello: Browser sends cipher list + random number
2. ServerHello: Server sends certificate + public key + random number
3. Key Exchange: Browser creates/derives session key (usually via ECDHE)
4. Server Confirms: Server derives the same key and sends encrypted Finished
5. Encrypted Session: All communication now uses symmetric AES-style encryption


### Setting up ssl 

```bash
# Navigate to nginx dir
cd /etc/nginx

# Make ssl dir
mkdir -p ssl

# Create ssl certificate using openssl library
openssl req -x509 -days 100 -nodes -newkey rsa:2048 -keyout /etc/nginx/ssl/self.key -out /etc/nginx/ssl/self.cert

# Now check certificate and ssl key 

# Now make changes in nginx.conf

server {
        listen 443 ssl;
        server_name agneypatel.info;
        ssl_certificate /etc/nginx/ssl/self.cert;
        ssl_certificate_key /etc/ngin/ssl/self.key;
}

# Now restart nginx
sudo systemctl restart nginx
```

### Enable http2 version

**why HTTP2 ?**
- HTTP1.1 was limited to processing only one outstanding request per TCP connection, forcing browsers to use mutliple TCP connections to process multiple requests simultaneously
- Web browsers using multiple connection to process additional requests occupy a greater share of the available network resources, hence downgrading network performance for other users 

**HTTP2 Feature Upgrades -**

**Multiplexed streams** - Bi-directional sequence of text format frames sent over the HTTP/2 protocol exchanged between the server and client are knows as "streams"
- Earlier iterations of the HTTP protocol were capable of transmitting only one stream at a time along with some time delay between each stream transmission
- HTTP2 helped server to disintegrate the HTTP payload into small, independent and managable interleaved sequence of frames. This information is then reassembled at the other end
- With this capability, data packages from multiple streams are essentially mixed and trandmitted over a single TCP connection. These packages are then split at the receiving end and presented as individual data streams. Transmitting mutliple requests simultaneously using HTTP version 1.1 or earlier required multiple TCP connections

**HTTP/2 Server Push -** - This capability allows the server to send additional cacheble information to the client that isn't requested but is antisipated in future requests
- This mechanism saves a request-respond round trip and reduces network latency
- The server can prioritize pushed resources - a key performance differentiator in HTTP/2 vs HTTP1

**Binary Protocols** - HTTP1.x used to process text commands to complete request-response cycles. HTTP/2 will use binary commands to execute the same tasks
- Effective network resource utilization
- Eliminating security associated with the texual nature of HTTP1.x such as response splitting attacks

**Stateful Header Compression**
- It uses the HPACK specification as a simple and secure approach to header compression. Both client and server maintain a list of headers used in previous client-server requests
- HPACK compresses the individual value of each header before it is transfered to the server, which then looks up the encoded information in list of preveously transfered header values to reconstuct the full header information.

**Benefits :**
- Web Performance
- Mobile web preformance
- Cheaper internet
- Epensive reach
- Media Rich Experience
- Improved Technology Utilization
- Security

### Enable HTTP2 Protocol

1. Find configure arguments using and copy them
```bash
nginx -V
```

2. Navigate to code directory and then use
```bash
./configure [**preveous configure arguments**] --with-http_v2_module
```

3. Make changes in http2
```bash
# In server block

server {
        listen 443 ssl http2;
}
```

* Now reload the nginx
```bash
nginx -s reload
sudo systemctl restart nginx
```

### NGINX Rate limit
